"""
Admission Admin Panel
=====================
Django Admin interface for Encounter and Procedure management.

Fortress Pattern Architecture:
- Strict Decoupling: No imports from external apps (patients, practitioners, locations)
- Raw Integer Display: All foreign references displayed as integer IDs
- Serializer Delegation: save_model delegates to serializers for business logic
- Read-Only Integrity: Generated fields (identifier, timestamps) are read-only

Author: WAH4H Backend Team
Date: February 4, 2026
"""

from django.contrib import admin
from django.contrib.auth import get_user_model
from .models import (
    Encounter, 
    Procedure, 
    ProcedurePerformer
)
from .serializers import EncounterSerializer, ProcedureSerializer

User = get_user_model()


# ==================== ENCOUNTER ADMIN ====================

@admin.register(Encounter)
class EncounterAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Encounter management.
    
    Fortress Pattern: Displays raw integer IDs, delegates to EncounterSerializer.
    No cross-app model imports or name resolution.
    """
    
    # List Display - Critical tracking information (Raw Integer IDs)
    list_display = (
        'encounter_id',
        'identifier',
        'status',
        'get_class_display',
        'type',
        'subject_id',
        'period_start',
    )
    
    # List Filters
    list_filter = (
        'status',
        'class_field',
        'type',
        'location_status',
        'period_start',
    )
    
    # Date Hierarchy for temporal navigation
    date_hierarchy = 'period_start'
    
    # Search Fields (Exact match on integer IDs)
    search_fields = (
        'identifier',
        '=subject_id',  # Exact match for patient ID (integer)
        '=participant_individual_id',  # Exact match for practitioner ID (integer)
        'type',
    )
    
    # Ordering
    ordering = ('-period_start', '-encounter_id')
    
    # Read-Only Fields (Generated by system/service)
    readonly_fields = (
        'encounter_id',
        'identifier',  # Generated by EncounterSerializer
        'created_at',
        'updated_at',
    )
    
    # Fieldsets - Logical grouping of fields
    fieldsets = (
        ('Identity & Classification', {
            'fields': (
                'encounter_id',
                'identifier',
                'status',
                'class_field',
                'type',
                'service_type',
                'priority',
            ),
            'description': 'Core identification and classification of the encounter.'
        }),
        
        ('Patient & Participants (Integer IDs)', {
            'fields': (
                'subject_id',
                'participant_individual_id',
                'participant_type',
                'service_provider_id',
            ),
            'description': 'Raw integer references. Frontend resolves names from local store.'
        }),
        
        ('Timing & History', {
            'fields': (
                'period_start',
                'period_end',
                'length',
                'episode_of_care_id',
                'based_on_service_request_id',
                'appointment_id',
                'part_of_encounter_id',
                'pre_admission_identifier',
            ),
            'description': 'Temporal information and historical relationships.'
        }),
        
        ('Hospitalization & Discharge', {
            'fields': (
                'admit_source',
                're_admission',
                'diet_preference',
                'special_courtesy',
                'special_arrangement',
                'discharge_destination_id',
                'discharge_disposition',
            ),
            'description': 'Admission and discharge details for inpatient encounters.',
            'classes': ('collapse',),
        }),
        
        ('Location Details (Integer IDs)', {
            'fields': (
                'location_id',
                'location_status',
                'location_period_start',
                'location_period_end',
                'location_physical_type',
            ),
            'description': 'Physical location information. Location ID is raw integer reference.',
            'classes': ('collapse',),
        }),
        
        ('Clinical & Diagnosis', {
            'fields': (
                'diagnosis_condition_id',
                'diagnosis_rank',
                'diagnosis_use',
                'reason_code',
                'reason_reference_id',
            ),
            'description': 'Clinical reasoning and diagnostic information.',
        }),
        
        ('Billing & Account', {
            'fields': (
                'account_id',
            ),
            'description': 'Financial and billing references.',
            'classes': ('collapse',),
        }),
        
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    def get_class_display(self, obj):
        """Custom display for class_field to avoid confusion with Python 'class' keyword."""
        return obj.class_field if obj.class_field else '-'
    get_class_display.short_description = 'Class'
    get_class_display.admin_order_field = 'class_field'
    
    def save_model(self, request, obj, form, change):
        """
        Fortress Pattern: Use EncounterSerializer for business logic.
        """
        if not change:
            # Creating new encounter
            serializer = EncounterSerializer(data=form.cleaned_data, context={'request': request})
            serializer.is_valid(raise_exception=True)
            created_encounter = serializer.save()
            obj.pk = created_encounter.pk
            obj.identifier = created_encounter.identifier
        else:
            # Updating existing encounter
            serializer = EncounterSerializer(obj, data=form.cleaned_data, partial=True, context={'request': request})
            serializer.is_valid(raise_exception=True)
            serializer.save()

    list_per_page = 25
    actions_on_top = True
    actions_on_bottom = False


# ==================== PROCEDURE ADMIN ====================

@admin.register(Procedure)
class ProcedureAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Procedure management.
    
    Fortress Pattern: Displays raw integer IDs, delegates to ProcedureSerializer.
    No cross-app model imports or name resolution.
    """
    
    list_display = (
        'procedure_id',
        'identifier',
        'status',
        'code_display',
        'subject_id',
        'encounter_id',
        'performed_datetime',
    )
    
    list_filter = (
        'status',
        'category_code',
        'performed_datetime',
    )
    
    date_hierarchy = 'performed_datetime'
    
    search_fields = (
        'identifier',
        'code_display',
        '=subject_id',
        '=encounter_id',
    )
    
    ordering = ('-performed_datetime', '-procedure_id')
    
    readonly_fields = (
        'procedure_id',
        'identifier',
        'recorder_id',
        'created_at',
        'updated_at',
    )
    
    fieldsets = (
        ('Identity & Status', {
            'fields': (
                'procedure_id',
                'identifier',
                'status',
                'status_reason_code',
                'status_reason_display',
            ),
            'description': 'Procedure identification and current status.'
        }),
        
        ('Procedure Coding', {
            'fields': (
                'code_code',
                'code_display',
                'category_code',
                'category_display',
                'body_site_code',
                'body_site_display',
            ),
            'description': 'Clinical coding information (ICD, SNOMED, etc.).'
        }),
        
        ('Subject & Context (Integer IDs)', {
            'fields': (
                'subject_id',
                'encounter_id',
                'based_on_id',
                'part_of_id',
                'recorder_id',
                'asserter_id',
                'location_id',
            ),
            'description': 'Raw integer references.'
        }),
        
        ('Performance Timing', {
            'fields': (
                'performed_datetime',
                'performed_period_start',
                'performed_period_end',
                'performed_string',
                'performed_age_value',
                'performed_age_unit',
                'performed_range_low',
                'performed_range_high',
            ),
            'description': 'When the procedure was performed.',
        }),
        
        ('Performers (Integer IDs)', {
            'fields': (
                'performer_actor_id',
                'performer_function_code',
                'performer_function_display',
                'performer_on_behalf_of_id',
            ),
            'description': 'Healthcare providers who performed the procedure.',
            'classes': ('collapse',),
        }),
        
        ('Clinical Reasoning', {
            'fields': (
                'reason_code_code',
                'reason_code_display',
                'reason_reference_id',
            ),
            'description': 'Why the procedure was performed.',
            'classes': ('collapse',),
        }),
        
        ('Outcome & Complications', {
            'fields': (
                'outcome_code',
                'outcome_display',
                'complication_code',
                'complication_display',
                'complication_detail_id',
                'follow_up_code',
                'follow_up_display',
            ),
            'description': 'Results and any complications from the procedure.'
        }),
        
        ('Devices & Materials', {
            'fields': (
                'focal_device_manipulated_id',
                'focal_device_action_code',
                'focal_device_action_display',
                'used_reference_id',
                'used_code_code',
                'used_code_display',
            ),
            'description': 'Devices and materials used during the procedure.',
            'classes': ('collapse',),
        }),
        
        ('Additional Information', {
            'fields': (
                'instantiates_canonical',
                'instantiates_uri',
                'note',
                'report_id',
            ),
            'description': 'Notes, reports, and protocol references.',
            'classes': ('collapse',),
        }),
        
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    def save_model(self, request, obj, form, change):
        """
        Fortress Pattern: Use ProcedureSerializer for business logic.
        """
        if not change:
            # Creating new procedure
            serializer = ProcedureSerializer(data=form.cleaned_data, context={'request': request})
            serializer.is_valid(raise_exception=True)
            created_procedure = serializer.save()
            obj.pk = created_procedure.pk
            obj.identifier = created_procedure.identifier
            obj.recorder_id = created_procedure.recorder_id
        else:
            # Updating existing procedure
            serializer = ProcedureSerializer(obj, data=form.cleaned_data, partial=True, context={'request': request})
            serializer.is_valid(raise_exception=True)
            serializer.save()
    
    list_per_page = 25
    actions_on_top = True
    actions_on_bottom = False


# ==================== PROCEDURE PERFORMER ADMIN ====================

@admin.register(ProcedurePerformer)
class ProcedurePerformerAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Procedure Performer management.
    """
    
    list_display = (
        'procedure_performer_id',
        'procedure',
        'performer_actor_id',
        'performer_function_display',
    )
    
    list_filter = (
        'performer_function_code',
    )
    
    search_fields = (
        '=performer_actor_id',
        'performer_function_display',
    )
    
    ordering = ('-procedure_performer_id',)
    
    readonly_fields = (
        'procedure_performer_id',
        'created_at',
        'updated_at',
    )
    
    fieldsets = (
        ('Identity', {
            'fields': (
                'procedure_performer_id',
                'procedure',
            ),
        }),
        ('Performer Information (Integer IDs)', {
            'fields': (
                'performer_actor_id',
                'performer_on_behalf_of_id',
                'performer_function_code',
                'performer_function_display',
            ),
        }),
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    list_per_page = 25
    actions_on_top = True
    actions_on_bottom = False