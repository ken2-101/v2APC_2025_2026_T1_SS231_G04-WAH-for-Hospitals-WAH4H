"""
Admission Admin Panel
=====================
Django Admin interface for Encounter and Procedure management.

Fortress Pattern Architecture:
- Strict Decoupling: No imports from external apps (patients, practitioners, locations)
- Raw Integer Display: All foreign references displayed as integer IDs
- Service Layer Delegation: save_model delegates to service classes for business logic
- Read-Only Integrity: Generated fields (identifier, timestamps) are read-only

Author: WAH4H Backend Team
Date: February 4, 2026
"""

from django.contrib import admin
from django.contrib.auth import get_user_model
from .models import (
    Encounter, 
    Procedure, 
    ProcedurePerformer
)
from .services import EncounterService, ProcedureService

User = get_user_model()


# ==================== ENCOUNTER ADMIN ====================

@admin.register(Encounter)
class EncounterAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Encounter management.
    
    Fortress Pattern: Displays raw integer IDs, delegates to EncounterService.
    No cross-app model imports or name resolution.
    """
    
    # List Display - Critical tracking information (Raw Integer IDs)
    list_display = (
        'encounter_id',
        'identifier',
        'status',
        'get_class_display',
        'type',
        'subject_id',
        'period_start',
    )
    
    # List Filters
    list_filter = (
        'status',
        'class_field',
        'type',
        'location_status',
        'period_start',
    )
    
    # Date Hierarchy for temporal navigation
    date_hierarchy = 'period_start'
    
    # Search Fields (Exact match on integer IDs)
    search_fields = (
        'identifier',
        '=subject_id',  # Exact match for patient ID (integer)
        '=participant_individual_id',  # Exact match for practitioner ID (integer)
        'type',
    )
    
    # Ordering
    ordering = ('-period_start', '-encounter_id')
    
    # Read-Only Fields (Generated by system/service)
    readonly_fields = (
        'encounter_id',
        'identifier',  # Generated by EncounterService
        'created_at',
        'updated_at',
    )
    
    # Fieldsets - Logical grouping of fields
    fieldsets = (
        ('Identity & Classification', {
            'fields': (
                'encounter_id',
                'identifier',
                'status',
                'class_field',
                'type',
                'service_type',
                'priority',
            ),
            'description': 'Core identification and classification of the encounter.'
        }),
        
        ('Patient & Participants (Integer IDs)', {
            'fields': (
                'subject_id',
                'participant_individual_id',
                'participant_type',
                'service_provider_id',
            ),
            'description': 'Raw integer references. Frontend resolves names from local store.'
        }),
        
        ('Timing & History', {
            'fields': (
                'period_start',
                'period_end',
                'length',
                'episode_of_care_id',
                'based_on_service_request_id',
                'appointment_id',
                'part_of_encounter_id',
                'pre_admission_identifier',
            ),
            'description': 'Temporal information and historical relationships.'
        }),
        
        ('Hospitalization & Discharge', {
            'fields': (
                'admit_source',
                're_admission',
                'diet_preference',
                'special_courtesy',
                'special_arrangement',
                'discharge_destination_id',
                'discharge_disposition',
            ),
            'description': 'Admission and discharge details for inpatient encounters.',
            'classes': ('collapse',),
        }),
        
        ('Location Details (Integer IDs)', {
            'fields': (
                'location_id',
                'location_status',
                'location_period_start',
                'location_period_end',
                'location_physical_type',
            ),
            'description': 'Physical location information. Location ID is raw integer reference.',
            'classes': ('collapse',),
        }),
        
        ('Clinical & Diagnosis', {
            'fields': (
                'diagnosis_condition_id',
                'diagnosis_rank',
                'diagnosis_use',
                'reason_code',
                'reason_reference_id',
            ),
            'description': 'Clinical reasoning and diagnostic information.',
        }),
        
        ('Billing & Account', {
            'fields': (
                'account_id',
            ),
            'description': 'Financial and billing references.',
            'classes': ('collapse',),
        }),
        
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    def get_class_display(self, obj):
        """Custom display for class_field to avoid confusion with Python 'class' keyword."""
        return obj.class_field if obj.class_field else '-'
    get_class_display.short_description = 'Class'
    get_class_display.admin_order_field = 'class_field'
    
    def save_model(self, request, obj, form, change):
        """
        Fortress Pattern: Delegate to EncounterService for business logic.
        
        - New encounters: Use EncounterService.create_encounter (generates identifier)
        - Updates: Use EncounterService.update_encounter (enforces business rules)
        """
        if not change:
            # Creating new encounter - delegate to service
            data = {
                'subject_patient_id': obj.subject_patient_id,
                'status': obj.status or 'arrived',
                'type': obj.type,
                'priority': obj.priority,
                'service_type': obj.service_type,
                'class_field': obj.class_field,
                'period_start': obj.period_start,
                'location_id': obj.location_id,
                'service_provider_id': obj.service_provider_id,
                'admit_source': obj.admit_source,
                're_admission': obj.re_admission,
                'participant_individual_id': obj.participant_individual_id,
                'participant_type': obj.participant_type,
                'episode_of_care_id': obj.episode_of_care_id,
                'based_on_service_request_id': obj.based_on_service_request_id,
                'appointment_id': obj.appointment_id,
            }
            
            # Remove None values
            data = {k: v for k, v in data.items() if v is not None}
            
            # Create via service (handles identifier generation and RBAC)
            created_encounter = EncounterService.create_encounter(
                user=request.user,
                data=data
            )
            
            # Update obj with generated values
            obj.pk = created_encounter.pk
            obj.identifier = created_encounter.identifier
        else:
            # Updating existing encounter - delegate to service
            update_data = {}
            for field in form.changed_data:
                if field not in ['encounter_id', 'identifier', 'created_at', 'updated_at']:
                    update_data[field] = getattr(obj, field)
            
            if update_data:
                EncounterService.update_encounter(
                    user=request.user,
                    encounter=obj,
                    data=update_data
                )
    
    # List per page
    list_per_page = 25
    
    # Enable actions
    actions_on_top = True
    actions_on_bottom = False


# ==================== PROCEDURE ADMIN ====================

@admin.register(Procedure)
class ProcedureAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Procedure management.
    
    Fortress Pattern: Displays raw integer IDs, delegates to ProcedureService.
    No cross-app model imports or name resolution.
    """
    
    # List Display (Raw Integer IDs)
    list_display = (
        'procedure_id',
        'identifier',
        'status',
        'code_display',
        'subject_id',
        'encounter_id',
        'performed_datetime',
    )
    
    # List Filters
    list_filter = (
        'status',
        'category_code',
        'performed_datetime',
    )
    
    # Date Hierarchy
    date_hierarchy = 'performed_datetime'
    
    # Search Fields (Exact match on integer IDs)
    search_fields = (
        'identifier',
        'code_display',
        '=subject_id',  # Exact match for patient ID (integer)
        '=encounter_id',  # Exact match for encounter ID (integer)
    )
    
    # Ordering
    ordering = ('-performed_datetime', '-procedure_id')
    
    # Read-Only Fields (Generated by system/service)
    readonly_fields = (
        'procedure_id',
        'identifier',  # Generated by ProcedureService
        'recorder_id',  # Set by ProcedureService from request.user
        'created_at',
        'updated_at',
    )
    
    # Fieldsets
    fieldsets = (
        ('Identity & Status', {
            'fields': (
                'procedure_id',
                'identifier',
                'status',
                'status_reason_code',
                'status_reason_display',
            ),
            'description': 'Procedure identification and current status.'
        }),
        
        ('Procedure Coding', {
            'fields': (
                'code_code',
                'code_display',
                'category_code',
                'category_display',
                'body_site_code',
                'body_site_display',
            ),
            'description': 'Clinical coding information (ICD, SNOMED, etc.).'
        }),
        
        ('Subject & Context (Integer IDs)', {
            'fields': (
                'subject_id',
                'encounter_id',
                'based_on_id',
                'part_of_id',
                'recorder_id',
                'asserter_id',
                'location_id',
            ),
            'description': 'Raw integer references. Frontend resolves names from local store.'
        }),
        
        ('Performance Timing', {
            'fields': (
                'performed_datetime',
                'performed_period_start',
                'performed_period_end',
                'performed_string',
                'performed_age_value',
                'performed_age_unit',
                'performed_range_low',
                'performed_range_high',
            ),
            'description': 'When the procedure was performed.',
        }),
        
        ('Performers (Integer IDs)', {
            'fields': (
                'performer_actor_id',
                'performer_function_code',
                'performer_function_display',
                'performer_on_behalf_of_id',
            ),
            'description': 'Healthcare providers who performed the procedure (raw integer IDs).',
            'classes': ('collapse',),
        }),
        
        ('Clinical Reasoning', {
            'fields': (
                'reason_code_code',
                'reason_code_display',
                'reason_reference_id',
            ),
            'description': 'Why the procedure was performed.',
            'classes': ('collapse',),
        }),
        
        ('Outcome & Complications', {
            'fields': (
                'outcome_code',
                'outcome_display',
                'complication_code',
                'complication_display',
                'complication_detail_id',
                'follow_up_code',
                'follow_up_display',
            ),
            'description': 'Results and any complications from the procedure.'
        }),
        
        ('Devices & Materials', {
            'fields': (
                'focal_device_manipulated_id',
                'focal_device_action_code',
                'focal_device_action_display',
                'used_reference_id',
                'used_code_code',
                'used_code_display',
            ),
            'description': 'Devices and materials used during the procedure.',
            'classes': ('collapse',),
        }),
        
        ('Additional Information', {
            'fields': (
                'instantiates_canonical',
                'instantiates_uri',
                'note',
                'report_id',
            ),
            'description': 'Notes, reports, and protocol references.',
            'classes': ('collapse',),
        }),
        
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    def save_model(self, request, obj, form, change):
        """
        Fortress Pattern: Delegate to ProcedureService for business logic.
        
        - New procedures: Use ProcedureService.record_procedure
        - Updates: Direct save (service doesn't have generic update method)
        """
        if not change:
            # Creating new procedure - delegate to service
            data = {
                'encounter_id': obj.encounter_id,
                'subject_id': obj.subject_id,
                'code_code': obj.code_code,
                'code_display': obj.code_display,
                'status': obj.status or 'completed',
                'category_code': obj.category_code,
                'category_display': obj.category_display,
                'performed_datetime': obj.performed_datetime,
                'body_site_code': obj.body_site_code,
                'body_site_display': obj.body_site_display,
                'reason_code_code': obj.reason_code_code,
                'reason_code_display': obj.reason_code_display,
                'outcome_code': obj.outcome_code,
                'outcome_display': obj.outcome_display,
                'note': obj.note,
                'location_id': obj.location_id,
                'performer_actor_id': obj.performer_actor_id,
                'performer_function_code': obj.performer_function_code,
                'performer_function_display': obj.performer_function_display,
            }
            
            # Remove None values
            data = {k: v for k, v in data.items() if v is not None}
            
            # Create via service (handles identifier generation, recorder_id, and RBAC)
            created_procedure = ProcedureService.record_procedure(
                user=request.user,
                data=data
            )
            
            # Update obj with generated values
            obj.pk = created_procedure.pk
            obj.identifier = created_procedure.identifier
            obj.recorder_id = created_procedure.recorder_id
        else:
            # Updating existing procedure - direct save
            # (ProcedureService doesn't have a generic update method)
            super().save_model(request, obj, form, change)
    
    # List per page
    list_per_page = 25
    
    # Enable actions
    actions_on_top = True
    actions_on_bottom = False


# ==================== PROCEDURE PERFORMER ADMIN ====================

@admin.register(ProcedurePerformer)
class ProcedurePerformerAdmin(admin.ModelAdmin):
    """
    Production-grade admin interface for Procedure Performer management.
    
    Fortress Pattern: Displays raw integer IDs.
    Expanded to match full CSV schema with all clinical details.
    """
    
    # List Display (Raw Integer IDs)
    list_display = (
        'procedure_performer_id',
        'procedure',
        'performer_actor_id',
        'performer_function_display',
    )
    
    # List Filters
    list_filter = (
        'performer_function_code',
    )
    
    # Search Fields (Exact match on integer IDs)
    search_fields = (
        '=performer_actor_id',  # Exact match for practitioner ID (integer)
        'performer_function_display',
    )
    
    # Ordering
    ordering = ('-procedure_performer_id',)
    
    # Read-Only Fields (Generated by system)
    readonly_fields = (
        'procedure_performer_id',
        'created_at',
        'updated_at',
    )
    
    # Fieldsets - Pure junction table structure
    fieldsets = (
        ('Identity', {
            'fields': (
                'procedure_performer_id',
                'procedure',
            ),
            'description': 'Core identification of the procedure performer junction record.'
        }),
        
        ('Performer Information (Integer IDs)', {
            'fields': (
                'performer_actor_id',
                'performer_on_behalf_of_id',
                'performer_function_code',
                'performer_function_display',
            ),
            'description': 'Healthcare provider information (raw integer IDs). Frontend resolves names from local store.',
        }),
        
        ('System Metadata', {
            'fields': (
                'created_at',
                'updated_at',
            ),
            'classes': ('collapse',),
        }),
    )
    
    # List per page
    list_per_page = 25
    
    # Enable actions
    actions_on_top = True
    actions_on_bottom = False